# -*- coding: utf-8 -*-
"""rot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BHew3HwlrPa_nNGgUFyppmWCdPgVwsmE
"""

import requests
import json


# You would then call call_scaledown like this:
# response = call_scaledown(prompt=prompt_template, context=masked_code)
# where masked_code is the string containing the masked code.

import json
import re

# The call_scaledown function is in a separate cell (VhgnLOXNcDkI)
# The prompt templates are in a separate cell (a1dfbed4)

# Example usage (assuming call_scaledown, prompt_template, and masked_code are defined):
# response = call_scaledown(prompt=prompt_template, context=masked_code)
# if response and response.status_code == 200:
#     response_text = response.text
#     parsed_predictions = extract_json_from_response(response_text)
#     if parsed_predictions:
#         actual_values = {'MASK_0': 'exists', 'MASK_1': 'process'} # Define your actual values
#         evaluation = evaluate_predictions(parsed_predictions, actual_values)
#         print("\nParsed Predictions:", parsed_predictions)
#         if evaluation:
#             print("\nEvaluation Results:")
#             for mask_id, result in evaluation.items():
#                 print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
# else:
#     print(f"Scaledown API call failed with status code: {response.status_code if response else 'N/A'}")
if __name__ == "__main__":
    
    import json
    import re
    from masking import mask_code
    from prompt import get_prompt
    from dotenv import dotenv_values

    scaledown_api_key = dotenv_values(".env").get("SCALEDOWN")
    headers = {
    'x-api-key': scaledown_api_key,
    'Content-Type': 'application/json'
    }

    prompt = get_prompt()

    # Original code to be masked with more attribute/method accesses
    original_code = """
import pandas as pd

class DataProcessor:
    def __init__(self, dataframe):
        self.df = dataframe

    def clean_data(self):
        # Drop rows with missing values
        self.df.dropna(inplace=True)
        # Convert a column to numeric, coercing errors
        self.df['some_column'] = pd.to_numeric(self.df['some_column'], errors='coerce')
        return self.df

    def analyze_data(self):
        # Calculate descriptive statistics
        description = self.df.describe()
        # Get the shape of the dataframe
        shape = self.df.shape
        return description, shape

# Example usage
data = {'col1': [1, 2, None, 4], 'some_column': ['10', '20', '30', 'forty']}
df = pd.DataFrame(data)

processor = DataProcessor(df)
cleaned_df = processor.clean_data()
description, shape = processor.analyze_data()

print(cleaned_df)
print(description)
print(shape)
    """

    # Use the mask_code function to generate masked code and actual mapping
    masked_code, actual_mapping = mask_code(original_code, 0.99)


    print("Original Code:")
    print(original_code)
    print("\nMasked Code:")
    print(masked_code)
    print("\nActual Mapping:")
    print(actual_mapping)

    # Assuming call_scaledown is defined in cell VhgnLOXNcDkI
    # Assuming no_prompt_template and reasoning_prompt_template are defined in cell a1dfbed4
    # Assuming masked_code is defined in cell QZQnFaC_vxTN

    # Send a sample call to the scaledown endpoint
    # Using the no_prompt_template and the masked_code from cell QZQnFaC_vxTN
    print("Sending sample call to scaledown endpoint...")
    sample_response = call_scaledown(prompt=prompt, context=masked_code)

    # Print the response status code and body for inspection
    print(f"\nResponse Status Code: {sample_response.status_code}")
    print("\nResponse Body:")
    print(sample_response.text)

    # Assuming sample_response is defined from the previous API call in cell 14f4c487
    # Assuming extract_json_from_response is defined in cell f3ee698c
    import json

    if sample_response and sample_response.status_code == 200:
        response_data = json.loads(sample_response.text)
        full_response_text = response_data.get('full_response')

        if full_response_text:
            print("Attempting to parse 'full_response':")
            parsed_predictions_from_full_response = extract_json_from_response(full_response_text)

            if parsed_predictions_from_full_response:
                print("\nSuccessfully parsed predictions from 'full_response':")
                print(parsed_predictions_from_full_response)
            else:
                print("\nCould not parse JSON predictions from 'full_response'.")
        else:
            print("'full_response' field not found in the response.")
    else:
        print("Sample API response is not available or the call was not successful.")

    # Assuming parsed_predictions_from_full_response is defined from the previous parsing step in cell e348937c
    # Assuming actual_mapping is defined from the masked code generation step in cell QZQnFaC_vxTN
    # Assuming evaluate_predictions is defined in cell f3ee698c

    if 'parsed_predictions_from_full_response' in locals() and parsed_predictions_from_full_response:
        print("Evaluating predictions...")
        evaluation_results = evaluate_predictions(parsed_predictions_from_full_response, actual_mapping)

        if evaluation_results:
            print("\nEvaluation Results:")
            for mask_id, result in evaluation_results.items():
                print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
        else:
            print("\nCould not evaluate predictions.")
    else:
        print("Parsed predictions are not available to evaluate.")

    # Assuming call_scaledown is defined in cell VhgnLOXNcDkI
    # Assuming reasoning_prompt_template is defined in cell a1dfbed4
    # Assuming extract_json_from_response and evaluate_predictions are defined in cell f3ee698c
    # Assuming masked_code and actual_mapping are defined in cell QZQnFaC_vxTN

    # Call the scaledown API with the reasoning prompt
    print("Sending call to scaledown endpoint with reasoning prompt...")
    response = call_scaledown(prompt=prompt, context=masked_code)

    # Check if the API call was successful
    if response and response.status_code == 200:
        response_text = json.loads(response.text).get("full_response")
        print("\nScaledown API Response (Reasoning Prompt):")
        print(response_text)

        # Extract JSON predictions from the response
        parsed_predictions = extract_json_from_response(response_text)

        if parsed_predictions:
            print("\nParsed Predictions (Reasoning Prompt):")
            print(parsed_predictions)

            # Evaluate the predictions
            evaluation = evaluate_predictions(parsed_predictions, actual_mapping)

            if evaluation:
                print("\nEvaluation Results (Reasoning Prompt):")
                for mask_id, result in evaluation.items():
                    print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
        else:
            print("\nCould not extract valid JSON predictions from the response (Reasoning Prompt).")

    else:
        print(f"\nScaledown API call failed with status code: {response.status_code if response else 'N/A'} (Reasoning Prompt)")
        if response:
            print("Response body:", response.text)