# -*- coding: utf-8 -*-
"""rot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BHew3HwlrPa_nNGgUFyppmWCdPgVwsmE
"""

import requests
import json



def call_scaledown(prompt, context, model="gemini-2.5-flash") -> requests.Response:
    """
    Calls the scaledown API with a vanilla configuration (scaledown.rate = 0).

    Args:
        prompt: The prompt for the API call.
        context: The context for the API call.
        model: The model to use for the API call.

    Returns:
        The response from the scaledown API.
    """
    url = "https://api.scaledown.xyz/compress/"
    payload = json.dumps({
      "context": context,
      "prompt": prompt,
      "model": model,
      "scaledown": {
        "rate": 0
      }
    })
    response = requests.request("POST", url, headers=headers, data=payload)
    return response


# You would then call call_scaledown like this:
# response = call_scaledown(prompt=prompt_template, context=masked_code)
# where masked_code is the string containing the masked code.

import json
import re

def extract_json_from_response(response_text):
    """
    Extracts the JSON block from the scaledown API response text,
    specifically looking for a JSON block within triple backticks (```json).

    Args:
        response_text: The text response from the scaledown API, potentially containing a JSON block within triple backticks and other text.

    Returns:
        A dictionary containing the parsed JSON, or None if no valid JSON block is found or parsing fails.
    """
    try:
        # Use regex to find the JSON block within triple backticks (```json)
        match = re.search(r'```json\s*(.*?)\s*```', response_text, re.DOTALL)

        if not match:
            print("Error: Could not find a JSON block within triple backticks in the response.")
            return None

        json_string = match.group(1)

        # Attempt to parse the extracted JSON string
        predictions = json.loads(json_string)
        return predictions

    except json.JSONDecodeError:
        print("Error: Could not parse JSON from the extracted string.")
        return None
    except Exception as e:
        print(f"An error occurred during JSON extraction or parsing: {e}")
        return None

def evaluate_predictions(predictions, actual_mapping):
    """
    Evaluates the model's predictions against the actual values.

    Args:
        predictions: A dictionary containing the model's predicted values.
        actual_mapping: A dictionary with the actual mapping of masked values to their replacements.

    Returns:
        A dictionary with the evaluation results.
    """
    evaluation_results = {}
    if predictions:
        for mask_id, actual_value in actual_mapping.items():
            predicted_value = predictions.get(mask_id)
            evaluation_results[mask_id] = {
                'predicted': predicted_value,
                'actual': actual_value,
                'correct': predicted_value == actual_value
            }
    return evaluation_results

# The call_scaledown function is in a separate cell (VhgnLOXNcDkI)
# The prompt templates are in a separate cell (a1dfbed4)

# Example usage (assuming call_scaledown, prompt_template, and masked_code are defined):
# response = call_scaledown(prompt=prompt_template, context=masked_code)
# if response and response.status_code == 200:
#     response_text = response.text
#     parsed_predictions = extract_json_from_response(response_text)
#     if parsed_predictions:
#         actual_values = {'MASK_0': 'exists', 'MASK_1': 'process'} # Define your actual values
#         evaluation = evaluate_predictions(parsed_predictions, actual_values)
#         print("\nParsed Predictions:", parsed_predictions)
#         if evaluation:
#             print("\nEvaluation Results:")
#             for mask_id, result in evaluation.items():
#                 print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
# else:
#     print(f"Scaledown API call failed with status code: {response.status_code if response else 'N/A'}")
if __name__ == "__main__":
    
    import json
    import re
    from masking import mask_code
    from prompt import get_prompt
    from dotenv import dotenv_values

    scaledown_api_key = dotenv_values(".env").get("SCALEDOWN")
    headers = {
    'x-api-key': scaledown_api_key,
    'Content-Type': 'application/json'
    }

    prompt = get_prompt()

    # Original code to be masked with more attribute/method accesses
    original_code = """
import pandas as pd

class DataProcessor:
    def __init__(self, dataframe):
        self.df = dataframe

    def clean_data(self):
        # Drop rows with missing values
        self.df.dropna(inplace=True)
        # Convert a column to numeric, coercing errors
        self.df['some_column'] = pd.to_numeric(self.df['some_column'], errors='coerce')
        return self.df

    def analyze_data(self):
        # Calculate descriptive statistics
        description = self.df.describe()
        # Get the shape of the dataframe
        shape = self.df.shape
        return description, shape

# Example usage
data = {'col1': [1, 2, None, 4], 'some_column': ['10', '20', '30', 'forty']}
df = pd.DataFrame(data)

processor = DataProcessor(df)
cleaned_df = processor.clean_data()
description, shape = processor.analyze_data()

print(cleaned_df)
print(description)
print(shape)
    """

    # Use the mask_code function to generate masked code and actual mapping
    masked_code, actual_mapping = mask_code(original_code, 0.99)


    print("Original Code:")
    print(original_code)
    print("\nMasked Code:")
    print(masked_code)
    print("\nActual Mapping:")
    print(actual_mapping)

    # Assuming call_scaledown is defined in cell VhgnLOXNcDkI
    # Assuming no_prompt_template and reasoning_prompt_template are defined in cell a1dfbed4
    # Assuming masked_code is defined in cell QZQnFaC_vxTN

    # Send a sample call to the scaledown endpoint
    # Using the no_prompt_template and the masked_code from cell QZQnFaC_vxTN
    print("Sending sample call to scaledown endpoint...")
    sample_response = call_scaledown(prompt=prompt, context=masked_code)

    # Print the response status code and body for inspection
    print(f"\nResponse Status Code: {sample_response.status_code}")
    print("\nResponse Body:")
    print(sample_response.text)

    # Assuming sample_response is defined from the previous API call in cell 14f4c487
    # Assuming extract_json_from_response is defined in cell f3ee698c
    import json

    if sample_response and sample_response.status_code == 200:
        response_data = json.loads(sample_response.text)
        full_response_text = response_data.get('full_response')

        if full_response_text:
            print("Attempting to parse 'full_response':")
            parsed_predictions_from_full_response = extract_json_from_response(full_response_text)

            if parsed_predictions_from_full_response:
                print("\nSuccessfully parsed predictions from 'full_response':")
                print(parsed_predictions_from_full_response)
            else:
                print("\nCould not parse JSON predictions from 'full_response'.")
        else:
            print("'full_response' field not found in the response.")
    else:
        print("Sample API response is not available or the call was not successful.")

    # Assuming parsed_predictions_from_full_response is defined from the previous parsing step in cell e348937c
    # Assuming actual_mapping is defined from the masked code generation step in cell QZQnFaC_vxTN
    # Assuming evaluate_predictions is defined in cell f3ee698c

    if 'parsed_predictions_from_full_response' in locals() and parsed_predictions_from_full_response:
        print("Evaluating predictions...")
        evaluation_results = evaluate_predictions(parsed_predictions_from_full_response, actual_mapping)

        if evaluation_results:
            print("\nEvaluation Results:")
            for mask_id, result in evaluation_results.items():
                print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
        else:
            print("\nCould not evaluate predictions.")
    else:
        print("Parsed predictions are not available to evaluate.")

    # Assuming call_scaledown is defined in cell VhgnLOXNcDkI
    # Assuming reasoning_prompt_template is defined in cell a1dfbed4
    # Assuming extract_json_from_response and evaluate_predictions are defined in cell f3ee698c
    # Assuming masked_code and actual_mapping are defined in cell QZQnFaC_vxTN

    # Call the scaledown API with the reasoning prompt
    print("Sending call to scaledown endpoint with reasoning prompt...")
    response = call_scaledown(prompt=prompt, context=masked_code)

    # Check if the API call was successful
    if response and response.status_code == 200:
        response_text = json.loads(response.text).get("full_response")
        print("\nScaledown API Response (Reasoning Prompt):")
        print(response_text)

        # Extract JSON predictions from the response
        parsed_predictions = extract_json_from_response(response_text)

        if parsed_predictions:
            print("\nParsed Predictions (Reasoning Prompt):")
            print(parsed_predictions)

            # Evaluate the predictions
            evaluation = evaluate_predictions(parsed_predictions, actual_mapping)

            if evaluation:
                print("\nEvaluation Results (Reasoning Prompt):")
                for mask_id, result in evaluation.items():
                    print(f"{mask_id}: Predicted='{result['predicted']}', Actual='{result['actual']}', Correct={result['correct']}")
        else:
            print("\nCould not extract valid JSON predictions from the response (Reasoning Prompt).")

    else:
        print(f"\nScaledown API call failed with status code: {response.status_code if response else 'N/A'} (Reasoning Prompt)")
        if response:
            print("Response body:", response.text)